<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>TechPulse Signals</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 40px auto; max-width: 800px; line-height: 1.5; }
    h1 { font-size: 2rem; font-weight: bold; margin-bottom: 20px; }
    ul { list-style: none; padding: 0; }
    li { margin-bottom: 12px; border-bottom: 1px solid #e0e0e0; padding-bottom: 8px; }
    a { color: #0366d6; text-decoration: none; }
    a:hover { text-decoration: underline; }
    .date { display:block; font-size: 0.75rem; color: #6a737d; margin-top: 4px; }
  </style>
</head>
<body>
  <h1>TechPulse Signals</h1>
  <p id="status">Loading tech signals...</p>
  <ul id="list" style="display:none;"></ul>
<script>
(function cleanupServiceWorkersAndCaches() {
  if ('serviceWorker' in navigator) {
    navigator.serviceWorker
      .getRegistrations()
      .then((registrations) => Promise.all(registrations.map((registration) => registration.unregister())))
      .catch(() => {});
  }

  if ('caches' in window) {
    caches
      .keys()
      .then((keys) => Promise.all(keys.map((key) => caches.delete(key))))
      .catch(() => {});
  }
})();

const FEEDS = [
  'https://techcrunch.com/feed/',
  'https://feeds.arstechnica.com/arstechnica/index',
  'https://www.theverge.com/rss/index.xml',
  'https://hnrss.org/frontpage',
  'https://www.reddit.com/r/MachineLearning/.rss',
  'https://www.reddit.com/r/technology/.rss',
  'https://www.wired.com/feed/rss',
  'https://www.bgr.com/feed/',
  'https://gizmodo.com/rss',
  'https://feeds.bloomberg.com/bloomberg/technologynews',
  'https://9to5mac.com/feed/',
  'https://www.pcmag.com/feed',
  'https://www.esquire.com/rss/all.xml',
  'https://www.cultofmac.com/feed/',
  'https://www.nytimes.com/wirecutter/feed/',
  'https://www.cnet.com/rss/news/',
  'https://feeds.marketwatch.com/marketwatch/topstories/',
  'https://www.macrumors.com/rss.php',
  'https://www.engadget.com/rss.xml',
  'https://www.fastcompany.com/rss',
  'https://www.pcgamer.com/rss/'
];

const REQUEST_TIMEOUT_MS = 12000;
const MAX_CONCURRENT_FEEDS = 6;

const FEED_FETCHERS = [
  (url) => url,
  (url) => `https://api.allorigins.win/raw?url=${encodeURIComponent(url)}`,
  (url) => `https://cors.isomorphic-git.org/${url}`,
  (url) => `https://corsproxy.io/?${encodeURIComponent(url)}`,
  (url) => `https://api.codetabs.com/v1/proxy?quest=${encodeURIComponent(url)}`
];

async function fetchWithTimeout(url, timeoutMs) {
  const controller = new AbortController();
  const timeoutId = setTimeout(() => controller.abort(), timeoutMs);

  try {
    return await fetch(url, { signal: controller.signal });
  } finally {
    clearTimeout(timeoutId);
  }
}

async function fetchFeedText(url) {
  let lastError = null;

  for (const buildUrl of FEED_FETCHERS) {
    try {
      const res = await fetchWithTimeout(buildUrl(url), REQUEST_TIMEOUT_MS);
      if (!res.ok) {
        throw new Error(`HTTP ${res.status}`);
      }

      const text = await res.text();
      if (!text || text.length < 32 || !text.includes('<')) {
        throw new Error('Unexpected response body');
      }

      return text;
    } catch (error) {
      lastError = error;
    }
  }

  throw lastError || new Error('All feed fetch attempts failed');
}

async function fetchFeed(url) {
  const text = await fetchFeedText(url);
  const parser = new DOMParser();
  const xml = parser.parseFromString(text, 'application/xml');

  if (xml.querySelector('parsererror')) {
    throw new Error('Invalid XML');
  }

  return Array.from(xml.querySelectorAll('item, entry'))
    .map((item) => {
      const title = item.querySelector('title')?.textContent?.trim() || '';
      const linkNode = item.querySelector('link');
      const linkAttr = linkNode?.getAttribute('href');
      const link = (linkAttr || linkNode?.textContent || '').trim();
      const pubNode = item.querySelector('pubDate, updated, published');
      const pubDate = pubNode?.textContent ? new Date(pubNode.textContent) : null;
      const validDate = pubDate && !Number.isNaN(pubDate.getTime()) ? pubDate : null;

      return { title, link, pubDate: validDate };
    })
    .filter((item) => item.title && item.link);
}

async function runFeedJobsWithConcurrency(items, limit, job) {
  const settledResults = [];
  let currentIndex = 0;

  async function worker() {
    while (currentIndex < items.length) {
      const index = currentIndex;
      currentIndex += 1;

      try {
        const value = await job(items[index]);
        settledResults[index] = { status: 'fulfilled', value };
      } catch (reason) {
        settledResults[index] = { status: 'rejected', reason };
      }
    }
  }

  const workerCount = Math.min(limit, items.length);
  const workers = Array.from({ length: workerCount }, () => worker());
  await Promise.all(workers);
  return settledResults;
}

async function loadFeeds() {
  const list = document.getElementById('list');
  const status = document.getElementById('status');
  const totalFeeds = FEEDS.length;
  let completed = 0;

  const updateStatus = () => {
    status.textContent = `Loading tech signals... (${completed}/${totalFeeds})`;
  };

  updateStatus();

  const settled = await runFeedJobsWithConcurrency(
    FEEDS,
    MAX_CONCURRENT_FEEDS,
    (feed) =>
      fetchFeed(feed)
        .then((items) => items)
        .finally(() => {
          completed += 1;
          updateStatus();
        })
  );
  const allItems = settled
    .filter((result) => result.status === 'fulfilled')
    .flatMap((result) => result.value);

  allItems.sort((a, b) => {
    const at = a.pubDate ? a.pubDate.getTime() : 0;
    const bt = b.pubDate ? b.pubDate.getTime() : 0;
    return bt - at;
  });

  if (allItems.length === 0) {
    status.textContent = 'No items found (feeds blocked or proxy down). Try again.';
    return;
  }

  list.innerHTML = '';
  status.style.display = 'none';
  list.style.display = 'block';

  allItems.slice(0, 50).forEach((item) => {
    const li = document.createElement('li');
    const link = document.createElement('a');
    link.href = item.link;
    link.target = '_blank';
    link.rel = 'noopener noreferrer';
    link.textContent = item.title;
    li.appendChild(link);

    if (item.pubDate) {
      const dateSpan = document.createElement('span');
      dateSpan.className = 'date';
      dateSpan.textContent = item.pubDate.toLocaleString();
      li.appendChild(dateSpan);
    }

    list.appendChild(li);
  });
}

loadFeeds();
</script>
</body>
</html>
